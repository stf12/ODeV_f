/**
 * \page page2 Getting Started
 *
 * \tableofcontents
 *
 * \section intro2 Introduction
 * This section aim to be a step by step guide to explain how to build an application using the ODeV framework. As example we will reuse the
 * \ref page1 "simple demo application" delivered with the framework.
 *
 * \subsection folder_organization Folder organization
 * Let's start giving a look at the folder organization of the framework as displayed in \ref fig19 "Fig.19".
 *
 * \anchor fig19 \image html 19_packaging_diagram.png "Fig.19 - Folder organization"
 *
 * There is a place for everything. A new component like a library can be be put inside the `system` folder. Services and drivers provided by the application
 * goes inside the `system\xxx\services` and `system\xxx\drivers` folder <a href="#footnote-1">[1]</a>. An example are the NucleoDriver.h and NucleoDriver.c files.
 * Generic application files as well as the files implementing the managed tasks of the application can be put inside the `include` and the `src` folders.
 *
 * \subsection design_pattern Design pattern
 * The folder organization respects the application design, that is a soft real time and event driven system designed in multiple (three) layers. So, if you think to a
 * managed task as a tip of a subsystem that uses services and drivers, then \ref fig24 "Fig.24" is easy to understand, and it displays the relationship between the
 * system layer.
 *
 * \anchor fig24 \image html 24_packaging_diagram_2.png "Fig.24 - 3 layers system"
 *
 * The map between folders and layer is displayed in the following table:
 *
 * | Layer | Folders                                                         |
 * | :---: | :-------------------------------------------------------------- |
 * | App   | include, src                                                    |
 * | 3     | system/xxx/services                                             |
 * | 2     | system/xxx/drivers                                              |
 * | 1     | system/xxx/cmsis, system/xxx/freertos, system/xxx/stn32-hal     |
 *
 * On the side of the three layers (see \ref fig01 "Fig.1") there are few common components used across all system layers. These export
 * some interfaces and implement common design patterns in order to decouple the application code from the algorithms implemented in
 * the framework.
 *
 *
 * \section mandatory_files Application mandatory files
 * The application must provide few files expected by the framework. It is also possible to modify and reuse the ones provided with the simple demo.
 * Basically these are configuration header files. The following list gives a short description of these files.
 * For more details look at the file documentation:
 *
 * - include/apperror.h - application specific error code.
 * - include/FreeRTOSConfig.h - FreeRTOS configuration file. For more information see [this web page](https://freertos.org/a00110.html).
 * - include/stm32_assert.h - file generated by CubeMX.
 * - include/stm32l4xx_hal_conf.h - STM32 HAL configuration file. It is generated by CubeMX.
 * - include/sysconfig.h - global system preferences file.
 * - include/sysdebug_config.h - debug log configuration file.
 * - src/App.c - define the application.
 * - src/stm32_assert.c - file generated by CubeMX.
 * - src/stm32l4xx_hal_timebase_TIM.c - HAL tick definition. File generated by CubeMX.
 * - src/stm32l4xx_it.c - global interrupt service routine definition file. It is generated by CubeMX.
 * - system/src/services/sysdebug_mx.c - configure the hardware resources used for the debug log.
 * - system/src/services/sysinit_mx.c - define the SystemClock_Config(), SysPowerConfig() and HAL_MspInit() functions.
 *
 * Other than the files generated by CubeMx, in the above list there are some files with a \e _mx suffix. Those files contains the copy&paste
 * of functions definitions generated by CubeMX.
 *
 * The CubeMX project used for the simple demo can be downloaded from this <a href="NUCLEO-L452RE.ioc" target="_blank"><b>link</b></a>.
 *
 * \section app_file The App.c file
 * In an ODeV based application the main() function and main.c file are provided by the framework and they are not intended to be modified by the developer.
 * The developer needs another file where to define the application entry points in order to integrate the application code with the framework.
 * In the simple demo this is done in the \b App.c file. In this file are defined two functions.
 *
 * The first one, SysLoadApplicationContext(), is called by the INIT task after the basic hardware resources (except the ones used by the managed tasks) have been
 * initialized, as well as the AED <a href="#footnote-2">[2]</a> and APMH <a href="#footnote-3">[3]</a> objects have been allocated and initialized. We use this function to instantiate the managed tasks, and to add them
 * to the ::ApplicationContext object passed as a parameter. To add a managed task to the ::ApplicationContext we use the ACAddTask() function.
 * In this way the INIT task is aware of all the application managed tasks.
 *
 * The second function redefined in the App.c file is the SysOnStartApplication(). This function is used to connect the managed tasks. In the sample demo case,
 * both managed tasks use the same driver object of type ::NucleoDriver. This function is called by the INIT task after all managed task have been initialized,
 * so it is safe to assume that the driver has been allocated. Note that to share the driver it is used a pointer to the the base interface ::IDriver, but we know that actual type of that object
 * is ::NucleoDriver.
 *
 * \subsection appfile_other Other optional stuff for the App.c file
 * If you remember \ref fig21 "Fig.21" the INIT task works with two other objects in order to implement the features of a real application. The simple demo does not use any error
 * management strategy, so it does not need to implement the ::IApplicationErrorDelegate interface. For this reason the demo uses the default ::NullErrorDelegate.
 * A more complex application, on the other side, has to deal with error. In this case the App.c file is a good place to redefine the SysGetErrorDelegate() function in order to
 * provide an application specific implementation of the AED.
 *
 * In the same way, it is possible to redefine the SysGetPowerModeHelper() function and provide an application specific APMH object.
 *
 * TO BE CONTINUED ...
 *
 * ----
 * <p id="footnote-1">[1] xxx stands for `src` or `include`.</p>
 * <p id="footnote-2">[2] AED is the Application Error Delegate. For more information see the section \ref error_advanced.</p>
 * <p id="footnote-3">[3] APMH is the Application Power Mode Helper. For more information see the section \ref power_management.</p>
 *
 *
 */
